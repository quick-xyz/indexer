# indexer/database/indexer/repositories/asset_price_repository.py

from typing import List, Optional, Dict
from decimal import Decimal
from sqlalchemy.orm import Session
from sqlalchemy import and_, desc, func

from ...connection import ModelDatabaseManager
from ..tables.asset_price import AssetPrice
from ....core.logging import IndexerLogger, log_with_context
from ....types import EvmAddress
from ...base_repository import BaseRepository
from ..tables.detail.pool_swap_detail import PricingDenomination

import logging


class AssetPriceRepository(BaseRepository):
    """
    Repository for OHLC candle data aggregated from trade pricing.
    
    Manages asset price candles per period for analytics and charting.
    Generated by the CalculationService from trade_details aggregation.
    
    Located in indexer database since OHLC data is model/asset-specific
    and used for model-specific analytics and visualization.
    """
    
    def __init__(self, db_manager: ModelDatabaseManager):
        super().__init__(db_manager, AssetPrice)
        self.logger = IndexerLogger.get_logger('database.repositories.asset_price')
    
    def create_ohlc_candle(
        self,
        session: Session,
        period_id: int,
        asset_address: str,
        denomination: PricingDenomination,
        open_price: Decimal,
        high_price: Decimal,
        low_price: Decimal,
        close_price: Decimal
    ) -> Optional[AssetPrice]:
        """Create a new OHLC candle record"""
        try:
            candle = AssetPrice(
                period_id=period_id,
                asset=asset_address.lower(),           # ✅ Fixed: Table uses 'asset'
                denom=denomination.value,              # ✅ Fixed: Table uses 'denom'
                open=float(open_price),                # ✅ Fixed: Table uses 'open'
                high=float(high_price),                # ✅ Fixed: Table uses 'high'
                low=float(low_price),                  # ✅ Fixed: Table uses 'low'
                close=float(close_price)               # ✅ Fixed: Table uses 'close'
                # ✅ Removed: volume, trade_count don't exist in table
            )
            
            session.add(candle)
            session.flush()
            
            log_with_context(
                self.logger, logging.DEBUG, "OHLC candle created",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                open_price=float(open_price),
                high_price=float(high_price),
                low_price=float(low_price),
                close_price=float(close_price)
            )
            
            return candle
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error creating OHLC candle",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value if denomination else None,
                error=str(e)
            )
            raise
    
    def get_candle(
        self,
        session: Session,
        period_id: int,
        asset_address: str,
        denomination: PricingDenomination
    ) -> Optional[AssetPrice]:
        """Get OHLC candle for a specific period"""
        try:
            return session.query(AssetPrice).filter(
                and_(
                    AssetPrice.period_id == period_id,
                    AssetPrice.asset == asset_address.lower(),    # ✅ Fixed: Table uses 'asset'
                    AssetPrice.denom == denomination.value       # ✅ Fixed: Table uses 'denom'
                )
            ).one_or_none()
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting OHLC candle",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            raise
    
    def get_candles_for_periods(
        self,
        session: Session,
        period_ids: List[int],
        asset_address: str,
        denomination: PricingDenomination
    ) -> List[AssetPrice]:
        """Get OHLC candles for multiple periods"""
        try:
            return session.query(AssetPrice).filter(
                and_(
                    AssetPrice.period_id.in_(period_ids),
                    AssetPrice.asset == asset_address.lower(),    # ✅ Fixed: Table uses 'asset'
                    AssetPrice.denom == denomination.value       # ✅ Fixed: Table uses 'denom'
                )
            ).order_by(AssetPrice.period_id).all()
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting OHLC candles for periods",
                periods_count=len(period_ids),
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            return []
    
    def find_periods_with_missing_candles(
        self,
        session: Session,
        asset_address: str,
        denomination: Optional[PricingDenomination] = None
    ) -> List[int]:
        """
        Find periods that should have OHLC candles but don't.
        
        This identifies periods where trade data exists but OHLC candles haven't been generated.
        """
        try:
            # This would need to be implemented based on your business logic
            # for determining which periods should have candles
            
            # For now, returning empty list - you can implement the logic
            # to check against trade_details table to find periods with trades
            # but missing OHLC candles
            
            log_with_context(
                self.logger, logging.DEBUG, "Finding missing candles - implementation needed",
                asset_address=asset_address,
                denomination=denomination.value if denomination else "all"
            )
            
            return []
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error finding periods with missing candles",
                asset_address=asset_address,
                denomination=denomination.value if denomination else "all",
                error=str(e)
            )
            return []
    
    def count_missing_candles(
        self,
        session: Session,
        asset_address: str,
        denomination: PricingDenomination
    ) -> int:
        """Count how many periods are missing OHLC candles"""
        try:
            missing_periods = self.find_periods_with_missing_candles(
                session, asset_address, denomination
            )
            return len(missing_periods)
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error counting missing candles",
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            return 0
    
    def get_latest_candle_timestamp(
        self,
        session: Session,
        asset_address: str
    ) -> Optional[str]:
        """Get the latest candle timestamp for an asset (any denomination)"""
        try:
            # Get the latest period ID
            latest_period_id = session.query(func.max(AssetPrice.period_id)).filter(
                AssetPrice.asset == asset_address.lower()    # ✅ Fixed: Table uses 'asset'
            ).scalar()
            
            if not latest_period_id:
                return None
            
            # Get the period timestamp from shared database
            # Note: This would need proper cross-database query handling
            # For now, just return the period_id as a string
            return str(latest_period_id)
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting latest candle timestamp",
                asset_address=asset_address,
                error=str(e)
            )
            return None
    
    def update_candle(
        self,
        session: Session,
        period_id: int,
        asset_address: str,
        denomination: PricingDenomination,
        **updates
    ) -> Optional[AssetPrice]:
        """Update existing OHLC candle"""
        try:
            candle = self.get_candle(session, period_id, asset_address, denomination)
            
            if not candle:
                return None
            
            for key, value in updates.items():
                if hasattr(candle, key):
                    setattr(candle, key, value)
            
            session.flush()
            
            log_with_context(
                self.logger, logging.DEBUG, "OHLC candle updated",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                updates=list(updates.keys())
            )
            
            return candle
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error updating OHLC candle",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            raise
    
    def bulk_create_candles(
        self,
        session: Session,
        candle_data: List[Dict]
    ) -> int:
        """Bulk create multiple OHLC candle records"""
        try:
            candles = []
            for data in candle_data:
                candle = AssetPrice(
                    period_id=data['period_id'],
                    asset=data['asset_address'].lower(),      # ✅ Fixed: Table uses 'asset'
                    denom=data['denomination'],               # ✅ Fixed: Table uses 'denom'
                    open=float(data['open_price']),           # ✅ Fixed: Table uses 'open'
                    high=float(data['high_price']),           # ✅ Fixed: Table uses 'high'
                    low=float(data['low_price']),             # ✅ Fixed: Table uses 'low'
                    close=float(data['close_price'])          # ✅ Fixed: Table uses 'close'
                    # ✅ Removed: volume, trade_count don't exist in table
                )
                candles.append(candle)
            
            session.add_all(candles)
            session.flush()
            
            log_with_context(
                self.logger, logging.INFO, "Bulk OHLC candles created",
                candle_count=len(candles)
            )
            
            return len(candles)
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error bulk creating OHLC candles",
                candle_count=len(candle_data),
                error=str(e)
            )
            raise
    
    def get_candle_stats(
        self,
        session: Session,
        asset_address: str,
        denomination: PricingDenomination
    ) -> Dict:
        """Get statistics about OHLC candles for an asset"""
        try:
            stats = session.query(
                func.count(AssetPrice.period_id).label('candle_count'),
                func.min(AssetPrice.period_id).label('earliest_period'),
                func.max(AssetPrice.period_id).label('latest_period'),
                func.avg(AssetPrice.close).label('avg_close_price'),       # ✅ Fixed: Table uses 'close'
                func.min(AssetPrice.low).label('lowest_price'),            # ✅ Fixed: Table uses 'low'
                func.max(AssetPrice.high).label('highest_price')           # ✅ Fixed: Table uses 'high'
            ).filter(
                and_(
                    AssetPrice.asset == asset_address.lower(),             # ✅ Fixed: Table uses 'asset'
                    AssetPrice.denom == denomination.value                 # ✅ Fixed: Table uses 'denom'
                )
            ).first()
            
            return {
                'candle_count': stats.candle_count or 0,
                'earliest_period': stats.earliest_period,
                'latest_period': stats.latest_period,
                'avg_close_price': float(stats.avg_close_price) if stats.avg_close_price else 0.0,
                'lowest_price': float(stats.lowest_price) if stats.lowest_price else 0.0,
                'highest_price': float(stats.highest_price) if stats.highest_price else 0.0
            }
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting candle stats",
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            return {}
# indexer/database/indexer/repositories/asset_price_repository.py

from typing import List, Optional, Dict
from decimal import Decimal
from sqlalchemy.orm import Session
from sqlalchemy import and_, desc, func

from ...connection import ModelDatabaseManager
from ..tables.asset_price import AssetPrice
from ....core.logging_config import IndexerLogger, log_with_context
from ....types import EvmAddress
from ...base_repository import BaseRepository
from ..tables.detail.pool_swap_detail import PricingDenomination

import logging


class AssetPriceRepository(BaseRepository):
    """
    Repository for OHLC candle data aggregated from trade pricing.
    
    Manages asset price candles per period for analytics and charting.
    Generated by the CalculationService from trade_details aggregation.
    
    Located in indexer database since OHLC data is model/asset-specific
    and used for model-specific analytics and visualization.
    """
    
    def __init__(self, db_manager: ModelDatabaseManager):
        super().__init__(db_manager, AssetPrice)
        self.logger = IndexerLogger.get_logger('database.repositories.asset_price')
    
    def create_ohlc_candle(
        self,
        session: Session,
        period_id: int,
        asset_address: str,
        denomination: PricingDenomination,
        open_price: Decimal,
        high_price: Decimal,
        low_price: Decimal,
        close_price: Decimal,
        volume: Decimal,
        trade_count: int
    ) -> Optional[AssetPrice]:
        """Create a new OHLC candle record"""
        try:
            candle = AssetPrice(
                period_id=period_id,
                asset_address=asset_address.lower(),
                denomination=denomination.value,
                open_price=float(open_price),
                high_price=float(high_price),
                low_price=float(low_price),
                close_price=float(close_price),
                volume=float(volume),
                trade_count=trade_count
            )
            
            session.add(candle)
            session.flush()
            
            log_with_context(
                self.logger, logging.DEBUG, "OHLC candle created",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                open_price=float(open_price),
                high_price=float(high_price),
                low_price=float(low_price),
                close_price=float(close_price),
                volume=float(volume),
                trade_count=trade_count
            )
            
            return candle
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error creating OHLC candle",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value if denomination else None,
                error=str(e)
            )
            raise
    
    def get_candle(
        self,
        session: Session,
        period_id: int,
        asset_address: str,
        denomination: PricingDenomination
    ) -> Optional[AssetPrice]:
        """Get OHLC candle for a specific period"""
        try:
            return session.query(AssetPrice).filter(
                and_(
                    AssetPrice.period_id == period_id,
                    AssetPrice.asset_address == asset_address.lower(),
                    AssetPrice.denomination == denomination.value
                )
            ).one_or_none()
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting OHLC candle",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            raise
    
    def get_candles_for_periods(
        self,
        session: Session,
        period_ids: List[int],
        asset_address: str,
        denomination: PricingDenomination
    ) -> List[AssetPrice]:
        """Get OHLC candles for multiple periods"""
        try:
            return session.query(AssetPrice).filter(
                and_(
                    AssetPrice.period_id.in_(period_ids),
                    AssetPrice.asset_address == asset_address.lower(),
                    AssetPrice.denomination == denomination.value
                )
            ).order_by(AssetPrice.period_id).all()
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting OHLC candles for periods",
                periods_count=len(period_ids),
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            return []
    
    def find_periods_with_missing_candles(
        self,
        session: Session,
        asset_address: str,
        denomination: Optional[PricingDenomination] = None
    ) -> List[int]:
        """
        Find periods that should have OHLC candles but don't.
        
        This identifies periods where trade data exists but OHLC candles haven't been generated.
        """
        try:
            # This would need to join with trade data to find periods with trades but no candles
            # For now, returning a placeholder implementation
            # You may want to adjust this based on your specific business logic
            
            from ...shared.tables.periods import Period, PeriodType
            
            # Get periods that have existing candles
            existing_candle_periods = session.query(AssetPrice.period_id.distinct())
            
            if denomination:
                existing_candle_periods = existing_candle_periods.filter(
                    and_(
                        AssetPrice.asset_address == asset_address.lower(),
                        AssetPrice.denomination == denomination.value
                    )
                )
            else:
                existing_candle_periods = existing_candle_periods.filter(
                    AssetPrice.asset_address == asset_address.lower()
                )
            
            existing_period_ids = {p.period_id for p in existing_candle_periods.all()}
            
            # Get all 5-minute periods (typical candle period)
            # This is a simplified implementation - you may want to join with trade data
            all_periods = session.query(Period.id).filter(
                Period.period_type == PeriodType.FIVE_MINUTE
            ).order_by(desc(Period.id)).limit(1000).all()  # Limit to recent periods
            
            missing_periods = [
                p.id for p in all_periods 
                if p.id not in existing_period_ids
            ]
            
            log_with_context(
                self.logger, logging.DEBUG, "Found periods with missing candles",
                asset_address=asset_address,
                denomination=denomination.value if denomination else "all",
                missing_periods=len(missing_periods)
            )
            
            return missing_periods
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error finding periods with missing candles",
                asset_address=asset_address,
                denomination=denomination.value if denomination else "all",
                error=str(e)
            )
            return []
    
    def get_candle_stats(
        self,
        session: Session,
        asset_address: str,
        denomination: PricingDenomination
    ) -> Dict:
        """Get statistics about OHLC candle coverage for an asset"""
        try:
            stats = session.query(
                func.count(AssetPrice.period_id).label('candle_count'),
                func.min(AssetPrice.period_id).label('earliest_period'),
                func.max(AssetPrice.period_id).label('latest_period'),
                func.avg(AssetPrice.close_price).label('avg_close_price'),
                func.min(AssetPrice.low_price).label('min_price'),
                func.max(AssetPrice.high_price).label('max_price'),
                func.sum(AssetPrice.volume).label('total_volume'),
                func.avg(AssetPrice.volume).label('avg_volume'),
                func.sum(AssetPrice.trade_count).label('total_trades')
            ).filter(
                and_(
                    AssetPrice.asset_address == asset_address.lower(),
                    AssetPrice.denomination == denomination.value
                )
            ).first()
            
            return {
                'candle_count': stats.candle_count or 0,
                'earliest_period': stats.earliest_period,
                'latest_period': stats.latest_period,
                'avg_close_price': float(stats.avg_close_price) if stats.avg_close_price else 0.0,
                'min_price': float(stats.min_price) if stats.min_price else 0.0,
                'max_price': float(stats.max_price) if stats.max_price else 0.0,
                'total_volume': float(stats.total_volume) if stats.total_volume else 0.0,
                'avg_volume': float(stats.avg_volume) if stats.avg_volume else 0.0,
                'total_trades': int(stats.total_trades) if stats.total_trades else 0
            }
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting candle stats",
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            return {}
    
    def count_missing_candles(
        self,
        session: Session,
        asset_address: str,
        denomination: PricingDenomination
    ) -> int:
        """Count how many periods are missing OHLC candles"""
        try:
            missing_periods = self.find_periods_with_missing_candles(
                session, asset_address, denomination
            )
            return len(missing_periods)
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error counting missing candles",
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            return 0
    
    def get_latest_candle_timestamp(
        self,
        session: Session,
        asset_address: str
    ) -> Optional[str]:
        """Get the latest candle timestamp for an asset (any denomination)"""
        try:
            # Get the latest period ID
            latest_period_id = session.query(func.max(AssetPrice.period_id)).filter(
                AssetPrice.asset_address == asset_address.lower()
            ).scalar()
            
            if not latest_period_id:
                return None
            
            # Get the period timestamp
            from ...shared.tables.periods import Period
            period = session.query(Period).filter(Period.id == latest_period_id).first()
            
            return period.timestamp.isoformat() if period else None
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error getting latest candle timestamp",
                asset_address=asset_address,
                error=str(e)
            )
            return None
    
    def update_candle(
        self,
        session: Session,
        period_id: int,
        asset_address: str,
        denomination: PricingDenomination,
        **updates
    ) -> Optional[AssetPrice]:
        """Update existing OHLC candle"""
        try:
            candle = self.get_candle(session, period_id, asset_address, denomination)
            
            if not candle:
                return None
            
            for key, value in updates.items():
                if hasattr(candle, key):
                    setattr(candle, key, value)
            
            session.flush()
            
            log_with_context(
                self.logger, logging.DEBUG, "OHLC candle updated",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                updates=list(updates.keys())
            )
            
            return candle
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error updating OHLC candle",
                period_id=period_id,
                asset_address=asset_address,
                denomination=denomination.value,
                error=str(e)
            )
            raise
    
    def bulk_create_candles(
        self,
        session: Session,
        candle_data: List[Dict]
    ) -> int:
        """Bulk create multiple OHLC candle records"""
        try:
            candles = []
            for data in candle_data:
                candle = AssetPrice(
                    period_id=data['period_id'],
                    asset_address=data['asset_address'].lower(),
                    denomination=data['denomination'],
                    open_price=float(data['open_price']),
                    high_price=float(data['high_price']),
                    low_price=float(data['low_price']),
                    close_price=float(data['close_price']),
                    volume=float(data['volume']),
                    trade_count=data['trade_count']
                )
                candles.append(candle)
            
            session.add_all(candles)
            session.flush()
            
            log_with_context(
                self.logger, logging.INFO, "Bulk OHLC candles created",
                candle_count=len(candles)
            )
            
            return len(candles)
            
        except Exception as e:
            log_with_context(
                self.logger, logging.ERROR, "Error bulk creating OHLC candles",
                candle_count=len(candle_data),
                error=str(e)
            )
            raise